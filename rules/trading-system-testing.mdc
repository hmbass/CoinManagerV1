---
globs: tests/*.py,test_*.py
description: Trading system testing standards and patterns
---

# íŠ¸ë ˆì´ë”© ì‹œìŠ¤í…œ í…ŒìŠ¤íŒ… í‘œì¤€

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì „ëµ ê°œìš”

### 1. í…ŒìŠ¤íŠ¸ í”¼ë¼ë¯¸ë“œ
```
    E2E Tests (ì ìŒ)
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Integration Tests (ë³´í†µ) 
 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Unit Tests (ë§ìŒ)
```

- **Unit Tests (70%)**: ê°œë³„ í•¨ìˆ˜/í´ë˜ìŠ¤ í…ŒìŠ¤íŠ¸
- **Integration Tests (20%)**: ëª¨ë“ˆ ê°„ ìƒí˜¸ì‘ìš© í…ŒìŠ¤íŠ¸  
- **E2E Tests (10%)**: ì „ì²´ ì‹œìŠ¤í…œ í”Œë¡œìš° í…ŒìŠ¤íŠ¸

### 2. í…ŒìŠ¤íŠ¸ ë¶„ë¥˜ë³„ ë””ë ‰í† ë¦¬
```
tests/
â”œâ”€â”€ unit/                    # ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ test_features.py     # í”¼ì²˜ ê³„ì‚° í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ test_scanner.py      # ìŠ¤ìºë„ˆ ë¡œì§ í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ test_signals.py      # ì‹ í˜¸ ìƒì„± í…ŒìŠ¤íŠ¸
â”‚   â””â”€â”€ test_risk.py         # ë¦¬ìŠ¤í¬ ê´€ë¦¬ í…ŒìŠ¤íŠ¸
â”œâ”€â”€ integration/             # í†µí•© í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ test_api_integration.py    # API ì—°ë™ í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ test_data_pipeline.py      # ë°ì´í„° íŒŒì´í”„ë¼ì¸ í…ŒìŠ¤íŠ¸
â”‚   â””â”€â”€ test_order_flow.py         # ì£¼ë¬¸ í”Œë¡œìš° í…ŒìŠ¤íŠ¸
â”œâ”€â”€ fixtures/                # í…ŒìŠ¤íŠ¸ ë°ì´í„°
â”‚   â”œâ”€â”€ sample_candles.json
â”‚   â”œâ”€â”€ sample_orderbook.json
â”‚   â””â”€â”€ mock_responses.py
â””â”€â”€ conftest.py             # ê³µí†µ í”½ìŠ¤ì²˜
```

## ğŸ”§ í…ŒìŠ¤íŠ¸ í”½ìŠ¤ì²˜ ë° Mock íŒ¨í„´

### 1. ê³µí†µ í”½ìŠ¤ì²˜ (conftest.py)
```python
import pytest
import pandas as pd
from datetime import datetime, timedelta
from src.utils.config import Config

@pytest.fixture
def sample_config():
    """í…ŒìŠ¤íŠ¸ìš© ì„¤ì •."""
    return Config(
        exchange={
            "base_url": "https://api.upbit.com",
            "timeout": 30
        },
        scanner={
            "rvol_threshold": 2.0,
            "spread_bp_max": 5
        }
    )

@pytest.fixture
def sample_candles():
    """í…ŒìŠ¤íŠ¸ìš© ìº”ë“¤ ë°ì´í„° (200ê°œ)."""
    base_time = datetime(2024, 1, 1, 9, 0)
    dates = [base_time + timedelta(minutes=5*i) for i in range(200)]
    
    return pd.DataFrame({
        'candle_date_time_kst': dates,
        'opening_price': [10000 + i for i in range(200)],
        'high_price': [10050 + i for i in range(200)],
        'low_price': [9950 + i for i in range(200)],
        'trade_price': [10000 + i for i in range(200)],
        'candle_acc_trade_volume': [1000 + i*10 for i in range(200)]
    })

@pytest.fixture
def sample_orderbook():
    """í…ŒìŠ¤íŠ¸ìš© ì˜¤ë”ë¶ ë°ì´í„°."""
    return {
        "market": "KRW-BTC",
        "timestamp": 1640995200000,
        "orderbook_units": [
            {
                "ask_price": 52000000,
                "bid_price": 51990000,
                "ask_size": 0.1,
                "bid_size": 0.15
            }
        ]
    }
```

### 2. API Mock íŒ¨í„´
```python
import pytest
from unittest.mock import AsyncMock, Mock, patch
import httpx

@pytest.fixture
def mock_upbit_client():
    """Upbit í´ë¼ì´ì–¸íŠ¸ Mock."""
    client = Mock()
    client.get_markets = AsyncMock(return_value=[
        {"market": "KRW-BTC", "korean_name": "ë¹„íŠ¸ì½”ì¸"},
        {"market": "KRW-ETH", "korean_name": "ì´ë”ë¦¬ì›€"}
    ])
    client.get_candles = AsyncMock()
    client.get_orderbook = AsyncMock()
    return client

class TestAPIIntegration:
    @pytest.mark.asyncio 
    async def test_api_timeout_handling(self):
        """API íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸."""
        with patch('httpx.AsyncClient.get') as mock_get:
            mock_get.side_effect = httpx.TimeoutException("Request timeout")
            
            from src.api.upbit_rest import UpbitRestClient
            client = UpbitRestClient("https://api.upbit.com")
            
            with pytest.raises(Exception, match="timeout"):
                await client.get_markets()
```

## ğŸ“Š í”¼ì²˜ ê³„ì‚° í…ŒìŠ¤íŠ¸ íŒ¨í„´

### 1. RVOL ê³„ì‚° í…ŒìŠ¤íŠ¸
```python
import pytest
import pandas as pd
from src.data.features import FeatureCalculator

class TestFeatureCalculator:
    
    def test_rvol_calculation_normal_case(self, sample_candles):
        """ì •ìƒ ì¼€ì´ìŠ¤ RVOL ê³„ì‚°."""
        calc = FeatureCalculator()
        volumes = sample_candles['candle_acc_trade_volume']
        
        rvol = calc.calculate_rvol(volumes)
        
        assert isinstance(rvol, float)
        assert rvol > 0
        
        # ë§ˆì§€ë§‰ ê±°ë˜ëŸ‰ì´ í‰ê· ë³´ë‹¤ ë†’ìœ¼ë¯€ë¡œ RVOL > 1
        expected = volumes.iloc[-1] / volumes.iloc[-21:-1].mean()
        assert abs(rvol - expected) < 0.001
    
    def test_rvol_insufficient_data(self):
        """ë°ì´í„° ë¶€ì¡± ì‹œ RVOL ê³„ì‚°."""
        calc = FeatureCalculator()
        volumes = pd.Series([1000, 1100, 1200])  # 21ê°œ ë¯¸ë§Œ
        
        rvol = calc.calculate_rvol(volumes)
        
        assert rvol == 1.0  # ê¸°ë³¸ê°’ ë°˜í™˜
    
    def test_rvol_zero_average(self):
        """í‰ê·  ê±°ë˜ëŸ‰ì´ 0ì¸ ê²½ìš°."""
        calc = FeatureCalculator()
        volumes = pd.Series([0] * 20 + [100])
        
        rvol = calc.calculate_rvol(volumes)
        
        assert rvol == 1.0  # 0ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ë°©ì§€
```

### 2. ìƒëŒ€ê°•ë„(RS) ê³„ì‚° í…ŒìŠ¤íŠ¸
```python
def test_relative_strength_calculation(self, sample_candles):
    """ìƒëŒ€ê°•ë„ ê³„ì‚° í…ŒìŠ¤íŠ¸."""
    calc = FeatureCalculator()
    
    # BTC ê°€ê²© ë°ì´í„°
    btc_prices = sample_candles['trade_price'] * 0.9  # ì‹¬ë³¼ë³´ë‹¤ ë‚®ì€ ìˆ˜ìµë¥ 
    symbol_prices = sample_candles['trade_price']
    
    rs = calc.calculate_relative_strength(symbol_prices, btc_prices, window=60)
    
    assert isinstance(rs, float)
    # ì‹¬ë³¼ì´ BTCë³´ë‹¤ ì„±ê³¼ê°€ ì¢‹ìœ¼ë¯€ë¡œ RS > 0
    assert rs > 0

def test_svwap_calculation(self, sample_candles):
    """ì„¸ì…˜ VWAP ê³„ì‚° í…ŒìŠ¤íŠ¸."""
    calc = FeatureCalculator()
    
    svwap = calc.calculate_session_vwap(
        sample_candles['trade_price'],
        sample_candles['candle_acc_trade_volume']
    )
    
    assert isinstance(svwap, float)
    assert svwap > 0
    
    # ìˆ˜ë™ ê³„ì‚°ê³¼ ë¹„êµ
    total_value = (sample_candles['trade_price'] * sample_candles['candle_acc_trade_volume']).sum()
    total_volume = sample_candles['candle_acc_trade_volume'].sum()
    expected_vwap = total_value / total_volume
    
    assert abs(svwap - expected_vwap) < 0.01
```

## ğŸ¯ ìŠ¤ìºë„ˆ í…ŒìŠ¤íŠ¸ íŒ¨í„´

```python
import pytest
from src.scanner.scanner import CandidateScanner

class TestCandidateScanner:
    
    @pytest.fixture
    def scanner(self, sample_config):
        return CandidateScanner(sample_config.scanner)
    
    def test_score_calculation(self, scanner):
        """í›„ë³´ ì ìˆ˜ ê³„ì‚° í…ŒìŠ¤íŠ¸."""
        features = {
            'RS': 0.05,           # 5% ìƒëŒ€ê°•ë„
            'RVOL': 3.0,          # 3ë°° ê±°ë˜ëŸ‰ ì¦ê°€
            'trend': 1,           # ìƒìŠ¹ ì¶”ì„¸
            'depth_score': 0.8    # ë†’ì€ ìœ ë™ì„±
        }
        
        score = scanner.calculate_score(features)
        
        # 0.4Ã—0.05 + 0.3Ã—2.0 + 0.2Ã—1 + 0.1Ã—0.8 = 0.9
        expected = 0.4 * 0.05 + 0.3 * 2.0 + 0.2 * 1 + 0.1 * 0.8
        assert abs(score - expected) < 0.001
    
    def test_candidate_filtering(self, scanner):
        """í›„ë³´ í•„í„°ë§ í…ŒìŠ¤íŠ¸."""
        candidates = [
            {'market': 'KRW-BTC', 'rvol': 3.0, 'spread_bp': 3, 'trend': 1, 'score': 0.9},
            {'market': 'KRW-ETH', 'rvol': 1.5, 'spread_bp': 4, 'trend': 1, 'score': 0.8},  # RVOL ë¶€ì¡±
            {'market': 'KRW-ADA', 'rvol': 2.5, 'spread_bp': 8, 'trend': 1, 'score': 0.7},  # ìŠ¤í”„ë ˆë“œ ë†’ìŒ
            {'market': 'KRW-DOT', 'rvol': 2.2, 'spread_bp': 4, 'trend': 0, 'score': 0.6}   # ì¶”ì„¸ ì—†ìŒ
        ]
        
        filtered = scanner.filter_candidates(candidates)
        
        assert len(filtered) == 1  # BTCë§Œ í†µê³¼
        assert filtered[0]['market'] == 'KRW-BTC'
```

## ğŸ“ˆ ì‹ í˜¸ ìƒì„± í…ŒìŠ¤íŠ¸ íŒ¨í„´

```python
import pytest
from src.signals.orb import ORBSignal

class TestORBSignal:
    
    @pytest.fixture
    def orb_signal(self, sample_config):
        return ORBSignal(sample_config.signals.orb)
    
    def test_orb_breakout_detection(self, orb_signal, sample_candles):
        """ORB ëŒíŒŒ ê°ì§€ í…ŒìŠ¤íŠ¸."""
        # 09:00-10:00 ë°•ìŠ¤ ì„¤ì • (ì¸ë±ìŠ¤ 0-11, 5ë¶„ë´‰ ê¸°ì¤€)
        morning_candles = sample_candles.iloc[:12].copy()
        
        # ëŒíŒŒ ìº”ë“¤ ì¶”ê°€ (ë°•ìŠ¤ ìƒë‹¨ + ATR * 0.1)
        box_high = morning_candles['high_price'].max()
        atr = 50.0  # í…ŒìŠ¤íŠ¸ìš© ATR
        breakout_price = box_high + (atr * 0.1)
        
        breakout_candle = {
            'candle_date_time_kst': pd.Timestamp('2024-01-01 10:05:00'),
            'high_price': breakout_price,
            'trade_price': breakout_price,
            'candle_acc_trade_volume': 2000  # ë†’ì€ ê±°ë˜ëŸ‰
        }
        
        signal = orb_signal.check_breakout(morning_candles, breakout_candle, atr)
        
        assert signal is not None
        assert signal['type'] == 'ORB_BREAKOUT'
        assert signal['entry_price'] == breakout_price
        assert 'stop_price' in signal
        assert 'target_price' in signal
```

## ğŸ›¡ï¸ ë¦¬ìŠ¤í¬ ê´€ë¦¬ í…ŒìŠ¤íŠ¸ íŒ¨í„´

```python
import pytest
from src.risk.guard import RiskGuard

class TestRiskGuard:
    
    @pytest.fixture
    def risk_guard(self, sample_config):
        return RiskGuard(sample_config.risk)
    
    def test_position_size_calculation(self, risk_guard):
        """í¬ì§€ì…˜ í¬ê¸° ê³„ì‚° í…ŒìŠ¤íŠ¸."""
        account_balance = 1000000  # 100ë§Œì›
        entry_price = 50000
        stop_price = 49000
        
        position_size = risk_guard.calculate_position_size(
            account_balance, entry_price, stop_price
        )
        
        # ìœ„í—˜ í•œë„ 0.4% ê¸°ì¤€
        risk_amount = account_balance * 0.004  # 4,000ì›
        expected_size = risk_amount / (entry_price - stop_price)  # 4,000 / 1,000 = 4
        
        assert position_size == expected_size
    
    def test_daily_drawdown_limit(self, risk_guard):
        """ì¼ì¼ ì†ì‹¤ í•œë„ í…ŒìŠ¤íŠ¸."""
        account_balance = 1000000
        realized_pnl = -12000  # -1.2% ì†ì‹¤
        
        should_stop = risk_guard.check_daily_drawdown(account_balance, realized_pnl)
        
        assert should_stop is True  # -1% í•œë„ ì´ˆê³¼
    
    def test_consecutive_loss_limit(self, risk_guard):
        """ì—°ì† ì†ì‹¤ ì œí•œ í…ŒìŠ¤íŠ¸."""
        trade_history = [
            {'symbol': 'KRW-BTC', 'pnl': -1000, 'timestamp': '2024-01-01T10:00:00'},
            {'symbol': 'KRW-BTC', 'pnl': -1500, 'timestamp': '2024-01-01T11:00:00'}
        ]
        
        should_block = risk_guard.check_consecutive_losses('KRW-BTC', trade_history)
        
        assert should_block is True  # 2íšŒ ì—°ì† ì†ì‹¤ë¡œ ì°¨ë‹¨
```

## ğŸ”Œ ì£¼ë¬¸ ì‹¤í–‰ í…ŒìŠ¤íŠ¸ íŒ¨í„´

```python
import pytest
from unittest.mock import AsyncMock, Mock
from src.order.executor import OrderExecutor

class TestOrderExecutor:
    
    @pytest.fixture
    def mock_upbit_order_client(self):
        client = Mock()
        client.place_order = AsyncMock()
        client.cancel_order = AsyncMock()
        client.get_order = AsyncMock()
        return client
    
    @pytest.mark.asyncio
    async def test_paper_trade_execution(self, mock_upbit_order_client):
        """í˜ì´í¼ íŠ¸ë ˆì´ë”© ì£¼ë¬¸ ì‹¤í–‰ í…ŒìŠ¤íŠ¸."""
        executor = OrderExecutor(mock_upbit_order_client, paper_mode=True)
        
        order_request = {
            'market': 'KRW-BTC',
            'side': 'bid',
            'ord_type': 'limit',
            'price': 50000,
            'volume': 0.001
        }
        
        result = await executor.place_order(order_request)
        
        # í˜ì´í¼ ëª¨ë“œì—ì„œëŠ” ì‹¤ì œ API í˜¸ì¶œ ì•ˆí•¨
        mock_upbit_order_client.place_order.assert_not_called()
        
        # ëª¨ì˜ ì²´ê²° ê²°ê³¼ í™•ì¸
        assert result['uuid'] is not None
        assert result['state'] == 'done'
        assert result['executed_volume'] == '0.001'
    
    @pytest.mark.asyncio
    async def test_order_retry_logic(self, mock_upbit_order_client):
        """ì£¼ë¬¸ ì¬ì‹œë„ ë¡œì§ í…ŒìŠ¤íŠ¸."""
        # ì²« ë²ˆì§¸ í˜¸ì¶œì€ ì‹¤íŒ¨, ë‘ ë²ˆì§¸ëŠ” ì„±ê³µ
        mock_upbit_order_client.place_order.side_effect = [
            Exception("Network error"),
            {'uuid': 'test-uuid', 'state': 'wait'}
        ]
        
        executor = OrderExecutor(mock_upbit_order_client, paper_mode=False)
        
        order_request = {'market': 'KRW-BTC', 'side': 'bid'}
        result = await executor.place_order(order_request)
        
        assert mock_upbit_order_client.place_order.call_count == 2
        assert result['uuid'] == 'test-uuid'
```

## ğŸª E2E í…ŒìŠ¤íŠ¸ íŒ¨í„´

```python
import pytest
from unittest.mock import patch, AsyncMock
from src.app import TradingApp

class TestTradingAppE2E:
    
    @pytest.mark.asyncio
    async def test_scan_to_report_flow(self, sample_config):
        """ìŠ¤ìº”ë¶€í„° ë¦¬í¬íŠ¸ ìƒì„±ê¹Œì§€ ì „ì²´ í”Œë¡œìš° í…ŒìŠ¤íŠ¸."""
        
        # Mock ì „ì²´ ì™¸ë¶€ ì˜ì¡´ì„±
        with patch('src.api.upbit_rest.UpbitRestClient') as mock_rest, \
             patch('src.api.upbit_ws.UpbitWebSocketClient') as mock_ws:
            
            # API ì‘ë‹µ Mock ì„¤ì •
            mock_rest.return_value.get_markets = AsyncMock(return_value=[
                {'market': 'KRW-BTC', 'korean_name': 'ë¹„íŠ¸ì½”ì¸'}
            ])
            mock_rest.return_value.get_candles = AsyncMock(return_value=[...])
            
            app = TradingApp(sample_config, paper_mode=True)
            
            # ì „ì²´ ì‹¤í–‰
            result = await app.run_scan_and_trade()
            
            # ê²°ê³¼ ê²€ì¦
            assert 'candidates' in result
            assert 'trades' in result
            assert 'daily_report' in result
            
            # ë¦¬í¬íŠ¸ íŒŒì¼ ìƒì„± í™•ì¸
            assert os.path.exists('runtime/reports/daily_report_20240101.json')
```

## ğŸ“‹ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ë° ì»¤ë²„ë¦¬ì§€

### 1. pytest ì„¤ì • (pytest.ini)
```ini
[tool:pytest]
testpaths = tests
python_files = test_*.py *_test.py
python_classes = Test*
python_functions = test_*
addopts = 
    --strict-markers
    --verbose
    --tb=short
    --cov=src
    --cov-report=html
    --cov-report=term-missing
    --cov-fail-under=80

markers =
    unit: Unit tests
    integration: Integration tests
    e2e: End-to-end tests
    slow: Slow running tests
```

### 2. í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ëª…ë ¹ì–´
```bash
# ì „ì²´ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
pytest

# ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë§Œ ì‹¤í–‰
pytest -m unit

# í†µí•© í…ŒìŠ¤íŠ¸ë§Œ ì‹¤í–‰  
pytest -m integration

# ì»¤ë²„ë¦¬ì§€ 80% ë¯¸ë§Œ ì‹œ ì‹¤íŒ¨
pytest --cov-fail-under=80

# ë³‘ë ¬ ì‹¤í–‰ (ë¹ ë¥¸ í…ŒìŠ¤íŠ¸)
pytest -n auto
```

ì´ í…ŒìŠ¤íŠ¸ í‘œì¤€ì„ ì¤€ìˆ˜í•˜ì—¬ ì•ˆì •ì ì´ê³  ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” íŠ¸ë ˆì´ë”© ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ì„¸ìš”.